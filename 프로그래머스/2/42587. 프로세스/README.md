# [level 2] 프로세스 - 42587 

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42587) 

### 성능 요약

메모리: 79.4 MB, 시간: 1.42 ms

### 구분

코딩테스트 연습 > 스택／큐

### 채점결과

정확성: 100.0<br/>합계: 100.0 / 100.0

### 제출 일자

2026년 01월 26일 22:24:59

### 문제 설명

<p>운영체제의 역할 중 하나는 컴퓨터 시스템의 자원을 효율적으로 관리하는 것입니다. 이 문제에서는 운영체제가 다음 규칙에 따라 프로세스를 관리할 경우 특정 프로세스가 몇 번째로 실행되는지 알아내면 됩니다.</p>
<div class="highlight"><pre class="codehilite"><code>1. 실행 대기 큐(Queue)에서 대기중인 프로세스 하나를 꺼냅니다.
2. 큐에 대기중인 프로세스 중 우선순위가 더 높은 프로세스가 있다면 방금 꺼낸 프로세스를 다시 큐에 넣습니다.
3. 만약 그런 프로세스가 없다면 방금 꺼낸 프로세스를 실행합니다.
  3.1 한 번 실행한 프로세스는 다시 큐에 넣지 않고 그대로 종료됩니다.
</code></pre></div>
<p>예를 들어 프로세스 4개 [A, B, C, D]가 순서대로 실행 대기 큐에 들어있고, 우선순위가 [2, 1, 3, 2]라면 [C, D, A, B] 순으로 실행하게 됩니다. </p>

<p>현재 실행 대기 큐(Queue)에 있는 프로세스의 중요도가 순서대로 담긴 배열 <code>priorities</code>와, 몇 번째로 실행되는지 알고싶은 프로세스의 위치를 알려주는 <code>location</code>이 매개변수로 주어질 때, 해당 프로세스가 몇 번째로 실행되는지 return 하도록 solution 함수를 작성해주세요.</p>

<hr>

<h5>제한사항</h5>

<ul>
<li><code>priorities</code>의 길이는 1 이상 100 이하입니다.

<ul>
<li><code>priorities</code>의 원소는 1 이상 9 이하의 정수입니다.</li>
<li><code>priorities</code>의 원소는 우선순위를 나타내며 숫자가 클 수록 우선순위가 높습니다.</li>
</ul></li>
<li><code>location</code>은 0 이상 (대기 큐에 있는 프로세스 수 - 1) 이하의 값을 가집니다.

<ul>
<li><code>priorities</code>의 가장 앞에 있으면 0, 두 번째에 있으면 1 … 과 같이 표현합니다.</li>
</ul></li>
</ul>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>priorities</th>
<th>location</th>
<th>return</th>
</tr>
</thead>
        <tbody><tr>
<td>[2, 1, 3, 2]</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>[1, 1, 9, 1, 1, 1]</td>
<td>0</td>
<td>5</td>
</tr>
</tbody>
      </table>
<h5>입출력 예 설명</h5>

<p>예제 #1</p>

<p>문제에 나온 예와 같습니다.</p>

<p>예제 #2</p>

<p>6개의 프로세스 [A, B, C, D, E, F]가 대기 큐에 있고 중요도가 [1, 1, 9, 1, 1, 1] 이므로 [C, D, E, F, A, B] 순으로 실행됩니다. 따라서 A는 5번째로 실행됩니다.</p>

<hr>

<p>※ 공지 - 2023년 4월 21일 문제 지문이 리뉴얼되었습니다.</p>


> 출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges

## 🧠 이번 문제를 통해 새로 알게 된 사실

### 1️⃣ Queue에 객체/배열 담기
큐에는 단순히 숫자만 넣는 것이 아니라,  
`new int[]{우선순위, 원래위치}` 와 같이 **배열을 넣어 여러 정보를 함께 관리**할 수 있다.

→ 데이터 자체 + 고유 식별자(인덱스)를 한 번에 추적 가능

---

### 2️⃣ 우선순위 비교 전략
큐 내부를 매번 전수 조사하지 않고,  
**우선순위 배열을 미리 정렬(`Arrays.sort`)** 한 뒤  
가장 큰 값의 인덱스(`big`)를 추적하는 방식으로 효율적인 비교가 가능하다.

---

### 3️⃣ 자바 문법 디테일 정리
- 배열 길이: `length`
- 문자열 길이: `length()`
- 같은 스코프 내 변수 **중복 선언 불가**
- `Queue` 인터페이스에서는  
  `push / pop` ❌ → `offer / poll` ⭕

---

## ⚙️ 주요 로직 설계

### 1️⃣ 데이터 바구니 생성
- 큐에 `[우선순위, 인덱스]` 형태로 모든 프로세스를 삽입

---

### 2️⃣ 기준점 마련
- `priorities` 배열을 정렬
- 가장 높은 우선순위를 가리키는 인덱스 `big` 설정

---

### 3️⃣ 순환 구조
1. 큐에서 하나 꺼냄
2. 현재 우선순위가 `priorities[big]` 와 같다면
   - 실행 (`answer++`)
   - `big--` 로 다음 최고 우선순위 갱신
3. 다르면
   - 다시 큐의 뒤로 삽입 (`q.offer(current)`)

---

### 4️⃣ 목표 도달 조건
- 실행되는 프로세스의 인덱스가 `location`과 일치하는 순간
- 즉시 결과 반환

---

## 🔍 오답 노트

❌ 문제점 1: 프로세스 위치 추적 실패

초기 구현에서는 우선순위 값만 큐에 저장하여
특정 프로세스(location)의 실행 시점을 추적할 수 없었다.

✅ 해결 방법

우선순위와 초기 인덱스를 함께 저장하여
프로세스의 원래 위치를 유지하도록 개선하였다.

int[] { priority, index }

❌ 문제점 2: 재삽입 로직 누락

현재 프로세스의 우선순위가 최대값이 아닐 경우
다시 큐에 삽입해야 하는데,
if 조건이 만족할 때만 처리하고
else 분기를 구현하지 않아 로직이 불완전했다.

✅ 해결 방법

if - else 구조를 명확히 구성하여
실행되지 않는 모든 경우에는 무조건 큐에 재삽입하도록 수정하였다.

❌ 문제점 3: 최대 우선순위(big) 갱신 오류

big 변수를 고정된 최대값처럼 사용하여
프로세스 실행 이후에도 다음 기준 우선순위가 갱신되지 않는 문제가 발생했다.

✅ 해결 방법

가장 높은 우선순위의 프로세스가 실행될 때마다
big-- 처리하여
다음 최대 우선순위를 기준으로 로직이 동작하도록 수정하였다.
